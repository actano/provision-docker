// Generated by CoffeeScript 1.11.1
(function() {
  var DockerClient, Promise, ProxiedSSHClient, SSHClient, _, colors, path, ref;

  Promise = require('bluebird');

  colors = require('colors/safe');

  _ = require('lodash');

  path = require('path');

  ref = require('./ssh-client'), SSHClient = ref.SSHClient, ProxiedSSHClient = ref.ProxiedSSHClient;

  DockerClient = require('./docker-client');

  module.exports = function(host, username, options) {
    var proxy;
    if (options == null) {
      options = {};
    }
    proxy = options.proxy;
    return {
      connect: Promise.coroutine(function*() {
        if (proxy != null) {
          this.sshClient = new ProxiedSSHClient({
            host: proxy,
            username: username,
            agent: process.env.SSH_AUTH_SOCK
          }, {
            host: host,
            username: username,
            agent: process.env.SSH_AUTH_SOCK
          });
        } else {
          this.sshClient = new SSHClient({
            host: host,
            username: username,
            agent: process.env.SSH_AUTH_SOCK
          });
        }
        yield this.sshClient.connect();
        return this.dockerClient = new DockerClient(this.sshClient, username);
      }),
      disconnect: Promise.coroutine(function*() {
        return (yield this.sshClient.close());
      }),

      /*
          Starts a new container from image `tag` with name `containerName`.
          Run configurations like port mapping and environment variables can be set
          via `runConfig`.
       */
      runContainer: Promise.coroutine(function*(tag, containerName, runConfig) {
        var _runConfig, files, targetDirectory;
        _runConfig = _.extend({}, runConfig, {
          containerName: containerName,
          tag: tag
        });
        if (runConfig.assets != null) {
          files = runConfig.assets.map(function(assetInfo) {
            return assetInfo.localPath;
          });
          targetDirectory = "/home/" + username + "/assets";
          yield this.uploadFiles(files, targetDirectory);
        }
        return (yield this.dockerClient.run(_runConfig));
      }),

      /*
          Execute a command` via ssh
       */
      exec: Promise.coroutine(function*(command) {
        return (yield this.sshClient.exec(command));
      }),

      /*
          Replaces the container `containerName` with a new container from image `tag`.
          Run configurations like port mapping and environment variables can be set
          via `runConfig`.
       */
      replaceContainer: Promise.coroutine(function*(tag, containerName, runConfig) {
        yield this.dockerClient.pull(tag);
        yield this.dockerClient.stop(containerName);
        yield this.dockerClient.rm(containerName);
        return (yield this.runContainer(tag, containerName, runConfig));
      }),

      /*
          Ensures that a container is running by checking if `healthCheckPort` is open.
          Does nothing when port is open. Otherwise a new container `containerName`
          will be started from image `tag`.
          Run configurations like port mapping and environment variables can be set
          via `runConfig`.
       */
      ensureContainer: Promise.coroutine(function*(healthCheckPort, tag, containerName, runConfig) {
        var isHealthy;
        console.log(colors.green("checking health of " + containerName));
        isHealthy = (yield this.checkHealth(host, healthCheckPort));
        if (isHealthy) {
          console.log(colors.green(containerName + " seems to be healthy"));
          return;
        }
        console.log(colors.yellow(containerName + " seems to be down"));
        console.log(colors.green("replacing " + containerName));
        return (yield this.replaceContainer(tag, containerName, runConfig));
      }),

      /*
          Login to private docker registry located at `registryHost` via `username` and `password`.
       */
      loginToRegistry: Promise.coroutine(function*(registryHost, username, password) {
        return (yield this.dockerClient.login(registryHost, username, password));
      }),

      /*
          Docker related cleanup.
       */
      cleanup: Promise.coroutine(function*() {
        return (yield this.dockerClient.removeDanglingImages());
      }),

      /*
          Checks if `port` is open on `host`.
       */
      checkHealth: Promise.coroutine(function*(host, port) {
        var exitCode;
        exitCode = (yield this.sshClient.exec("nc -z " + host + " " + port));
        if (exitCode === 0) {
          return true;
        }
        return false;
      }),

      /*
          Uploads `files` to the remote directory `targetDirectory`.
       */
      uploadFiles: Promise.coroutine(function*(files, targetDirectory) {
        var exitCode, file, i, len, remotePath, results;
        exitCode = (yield this.sshClient.exec("mkdir -p " + targetDirectory));
        if (exitCode !== 0) {
          throw new Error("error while creating directory " + targetDirectory);
        }
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          remotePath = path.join(targetDirectory, path.basename(file));
          console.log(colors.green("uploading file '" + file + "' to remote path " + remotePath));
          results.push((yield this.sshClient.uploadFile(file, remotePath)));
        }
        return results;
      }),

      /*
          Download `file` from remote and save as `targetFile`.
       */
      downloadFile: Promise.coroutine(function*(file, targetFile) {
        if (!(yield this.sshClient.fileExists(file))) {
          throw new Error("error while downloading file '" + file + "': File does not exist");
        }
        console.log(colors.green("downloading file '" + file + "' to local path " + targetFile));
        return (yield this.sshClient.downloadFile(file, targetFile));
      }),

      /*
          Sends `signal` to container with name `containerName`.
       */
      sendSignalToContainer: Promise.coroutine(function*(containerName, signal) {
        return (yield this.dockerClient.sendSignalToContainer(containerName, signal));
      })
    };
  };

}).call(this);
